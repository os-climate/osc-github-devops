---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2024 The Linux Foundation

name: "📦 [R] PyPI Publishing"
# Publishes a Python package to PyPI"

on:
  workflow_call:
    inputs:
      PUBLISH_URL:
        description: "URL/prefix for package repository"
        type: string
        required: true
      ENVIRONMENT:
        # Environment MUST match the trusted publishing setup in PyPI, if defined
        description: "Mandatory environment, e.g. development, production"
        type: string
        required: false
        default: "production"
      BUILD_TAG:
        description: "Semantic tag for this release/build"
        type: string
        required: true
      ARTEFACT_LOCATION:
        description: "Path/location for build artefacts"
        type: string
        required: false
        default: "dist"
      ONE_PASSWORD_ITEM:
        description: "Path to 1Password vault credential for PyPI"
        type: string
        required: false
    secrets:
      OP_SERVICE_ACCOUNT_TOKEN:
        description: "1Password service account credential to access vault"
        required: false
      PYPI_CREDENTIAL:
        description: "PyPI API credential from GitHub secrets"
        required: false

permissions: {}

jobs:
  pypi-publish:
    name: "PyPI Publishing"
    runs-on: "ubuntu-latest"
    environment:
      name: ${{ inputs.environment }}
    permissions:
      # Needed for trusted publishing; must also be passed from parent workflows
      id-token: write
    steps:
      # Need repository content to extract project name
      - uses: actions/checkout@v4

      - name: "Extract project/repository naming"
        id: naming
        # yamllint disable-line rule:line-length
        uses: os-climate/osc-github-devops/.github/actions/python-project-name@main

      - name: "⬇ Download build artefacts"
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.python_project_name }}
          path: ${{ inputs.artefact_location }}

      - name: "Manicure artefacts directory"
        id: files
        run: |
          # Remove file types unsupported by the Python Package Index
          if [ ! -d  ${{ inputs.artefact_location }} ]; then
            echo "Early exit; build artefacts path NOT found:  ${{ inputs.artefact_location }}"
            exit 0
          fi
          if [ -f  ${{ inputs.artefact_location }}/buildvars.txt ]; then
            rm ${{ inputs.artefact_location }}/buildvars.txt
          else
            echo "No buildvars.txt file to purge"
          fi
          # Remove outputs related to SigStore signing
          if test -n "$(find ${{ inputs.artefact_location }} -maxdepth 1 -name '*.sigstore*' -print -quit)"
          then
            echo "Found SigStore signing artefacts to purge"
            rm  ${{ inputs.artefact_location }}/*.sigstore*
          else
            echo "No SigStore signing artefacts to purge"
          fi

      - name: "Checking Destination for Project"
        id: project-url-check
        # yamllint disable-line rule:line-length
        uses: os-climate/osc-github-devops/.github/actions/url-validity-check@main
        with:
          # e.g. "https://test.pypi.org/project/ITR/"
          prefix: "${{ inputs.PUBLISH_URL }}/project"
          string: "/${{ steps.naming.outputs.python_project_name }}"
          suffix: "/"

      - name: "Checking Destination for Build/Release"
        id: build-url-check
        # yamllint disable-line rule:line-length
        uses: os-climate/osc-github-devops/.github/actions/url-validity-check@main
        with:
          prefix: "${{ inputs.PUBLISH_URL }}/project"
          # e.g. "https://test.pypi.org/project/ITR/v1.0.0/"
          string: "/${{ steps.naming.outputs.python_project_name }}"
          suffix: "/${{ inputs.build_tag }}/"

      - name: "Conditional publishing checks"
        id: conditions
        shell: bash
        run: |
          # Conditional publishing checks

          if [ "${{ steps.project-url-check.outputs.valid }}" = "true" ]; then
            echo "Project has previously been published ✅"
            publish_method="Trusted Publishing"
          fi

          # Temporarily bypass trusted publishing
          # ToDo: remove line below when supporting reusable workflows
          publish_method="Trusted Publishing Bypassed"

          if [ "${{ inputs.PUBLISH_URL }}" = "https://pypi.org" ] && \
          [ "${{ steps.build-url-check.outputs.valid }}" == 'true' ]; then
            echo "This build/release has already been published ❌"
            echo "This build/release has already been published ❌" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          elif [ "${{ steps.build-url-check.outputs.valid }}" == 'true' ]; then
            echo "This build/release has already been published ❌"
            publish_method="Skipped"
            # Skip the rest of the logic in this step for test/development builds
            exit 0
          else
            echo "This build/release has NOT previously been published ✅"
          fi

          if [ "$publish_method" != "Trusted Publishing" ] && [ "$publish_method" = "Skipped" ]; then
            echo "Trusted publishing NOT available, using fallback methods 👇🏻"

            ### 1Password Vault Credential ###

            if [ -z "$OP_SERVICE_ACCOUNT_TOKEN" ] || [ -z "$ONE_PASSWORD_ITEM" ]; then
              echo "Unable to use 1Password to retrieve publishing key ❌"
              echo "Two required parameters MUST be set/available"
              echo "Secret:   OP_SERVICE_ACCOUNT_TOKEN"
              echo "Variable: ONE_PASSWORD_ITEM"
            else
              echo "Authentication will use 1Password vault ✅"
              publish_method="1Password Vault"
            fi

            ### GitHub Secret ###

            if [ -z "$PYPI_CREDENTIAL" ]; then
              echo "GitHub credential NOT set/available: PYPI_CREDENTIAL"
              echo "Publishing cannot continue without a valid method ❌"
              echo "Publishing cannot continue without a valid method ❌" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            else
              echo "Authentication will use GitHub secret ✅"
              publish_method="GitHub Secret"
            fi

          fi

          if [ "$publish_method" != "none" ]; then
            echo "Publishing to: ${{ inputs.PUBLISH_URL }} [ ${{ inputs.ENVIRONMENT }} ]"
            echo "publish_method=$publish_method" >> "$GITHUB_ENV"
            echo "publish_method=$publish_method" >> "$GITHUB_OUTPUT"
          fi

      # Temporarily disabled due to OIDC (and token/claim complications)
      # This is all about job_workflow_ref vs ref
      # e.g. https://github.com/pypi/warehouse/issues/11096
      # https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows

      - name: "Publish PyPI [${{ steps.conditions.outputs.publish_method }}]"
        uses: pypa/gh-action-pypi-publish@15c56dba361d8335944d31a2ecd17d700fc7bcbc # v1.12.2
        # yamllint disable-line rule:line-length
        if: steps.conditions.outputs.publish_method == 'Trusted Publishing'
        with:
          repository-url: "${{ inputs.PUBLISH_URL }}/legacy/"
          # Show checksum values
          print-hash: true
          packages-dir: ${{ env.ARTEFACT_LOCATION }}
          # We already validated earlier in the pipeline (using twine)
          verify-metadata: false
          # Optional debugging, pretty much essential for information on failures
          verbose: true
          attestations: false # Currently too buggy to enable
          # attestations: true

      - name: "Retrieve Credential [1Password]"
        id: one-password-pypi-test
        if: steps.conditions.outputs.publish_method == '1Password Vault'
        uses: 1password/load-secrets-action@581a835fb51b8e7ec56b71cf2ffddd7e68bb25e0 # v2.0.0
        with:
          # Export loaded secrets as environment variables
          export-env: true
        env:
          PYPI_CREDENTIAL: "${{ inputs.ONE_PASSWORD_ITEM}}"
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      # Used only once prior to trusted publishing being configured
      - name: "Publish PyPI [${{ steps.conditions.outputs.publish_method }}]"
        uses: pypa/gh-action-pypi-publish@15c56dba361d8335944d31a2ecd17d700fc7bcbc # v1.12.2
        if: steps.conditions.outputs.publish_method == '1Password Vault'
        with:
          repository-url: "${{ inputs.PUBLISH_URL }}/legacy/"
          print-hash: true
          packages-dir: ${{ env.ARTEFACT_LOCATION }}
          verify-metadata: false
          verbose: true
          # Credential retrieved from 1Password using service account
          password: "${{ env.PYPI_CREDENTIAL}}"
          attestations: false

      # Fallback method using credential stored as GitHub secret
      - name: "Publish PyPI [${{ steps.conditions.outputs.publish_method }}]"
        uses: pypa/gh-action-pypi-publish@15c56dba361d8335944d31a2ecd17d700fc7bcbc # v1.12.2
        if: steps.conditions.outputs.publish_method == 'GitHub Secret'
        with:
          repository-url: https://test.pypi.org/legacy/
          print-hash: true
          packages-dir: ${{ env.ARTEFACT_LOCATION }}
          verify-metadata: false
          verbose: true
          # Publishing API key stored as secret/variable in GitHub
          password: ${{ secrets.PYPI_CREDENTIAL }}
          attestations: false

      - name: "Print summary/job output"
        shell: bash
        # yamllint disable rule:line-length
        run: |
          # Print summary/job output
          if [ "${{ steps.conditions.outputs.publish_method }}" = "Skipped" ]; then
            echo "# Publishing skipped due to existing content ⛔️" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          elif [ ${{ inputs.PUBLISH_URL }} != "https://pypi.org" ]; then
            echo "# ✅ Published successfully" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "# 🚀 Published to PyPI" >> "$GITHUB_STEP_SUMMARY"
          fi
          echo "Publishing method: ${{ steps.conditions.outputs.publish_method }}"
          echo "${{ inputs.PUBLISH_URL }}/project/${{ steps.naming.outputs.python_project_name }}/${{ inputs.build_tag }}/" >> "$GITHUB_STEP_SUMMARY"
